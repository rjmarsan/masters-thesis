\chapter{Evaluation}
\label{sec:framework}

With AndroMEDA, we attempt to build on top of the Android Permission system, to do a better job at enforcing the User-App Agreement. The main reasons why the Permission System failed to differentiate between malware and normal software can be seen as a lack of context and understanding of use. When an app requests a permission, it is granted to the app reguardless of any context - at any time, and reguardless of user consent. The data, after being requested, ultimately can be manipulated and trasmitted to any party without user consent. 

Projects like TaintDroid\citep{enck2010taintdroid} have begun to address the flow of personal data, which aids in the user understanding the use of data. However, much more can be done to address both context and use, which AndroMEDA addresses. By instrumenting API calls, AndroMEDA can both inspect context use of personal data as well as other important system actions. By presenting this normally hidden information to the user, AndroMEDA provides them with a feedback loop to evaulate whether the User-App Agreement has been broken.

\section{Existing Malware Datasets}
To test the effectiveness of AndroMEDA at detecting malicious behavior, we begin with testing apps from the Android Malware Genome Project\citep{zhou2012dissecting}, the most comprehensive academic malware dataset. Unfortunately, we found only 31 (2.4\%) of the nearly 1300 samples were designed for Android 2.3 and above, when Android fixed many rootkits, and not a single one targeted Android 4.0 or above, when Android took steps to fix SMS related malware. Furthermore, we found many of the samples simply did not run anymore, due to deprecated APIs and other poor coding techniques.


To test a future-malware oriented framework, it would be ideal to have more sophisticated malware. Rootkits and Premium SMS malware have been addressed by recent versions of Android, so we focus on what we believe to be the future of malware on Android: Sophisticated Info Theft Apps. The concept of hiding Info Theft Malware inside of benign apps, designed to silently steal PII and perform other unwanted operations, we have dubbed IncognitoWare. Since our analysis of Permissions in the GPStore has shown that popular apps tend to request a large amount of PII-related permissions, we can fit them all within the existing Permission Fingerprint. 

\section{IncognitoWare}
IncognitoWare has recently became one of the most popular forms of mobile malware\citep{nq2013}. FakeInst\citep{avastfakeinst} was a repackaged version of Instagram\citep{instagramandroid} that sent premium SMS messages on start. While admittely basic, more complex versions, like FakeAngry\citep{fakeangry} have been found, imitating popular games, while in the background stealing PII, installing a rootkit and joining a botnet.

We introduce a novel set of research IncognitoWare, as a representitive sample of current and future mobile malware techniques. Our first example sends as much PII as it can find to a remote server, the second silently monitors the phone in the background. We chose not to include a Premium SMS Malware sample, despite it's popularity\citep{nq2013}, due to it being addressed in the latest version of Android. By analyzing our framework with this dataset, we hope to demonstrate the effectiveness of addressing the UAA as a main route to detecting malware.

Creating IncognitoWare is straightforward. First, an exploit is designed, and coded as it's own app. Second, the \textit{apktool}\citep{apktool} utility decompiles any APK file into a set of resources and \textit{smali} files - decompiled Dalivk bytecode. From there, the \textit{apktool} utility is used again on the exploit, and the \textit{smali} code trees are merged. The exploit entry points are then placed inside of the host app's code, and \textit{apktool} rebuilds the project back into an APK file. This APK is unsigned, and requires the malware writer to resign it. This mismatched signature makes the APK unsuitable for uploading to the Google Play Store, but by changing the Android package to something slightly different, it's suitable for deployment in the Google Play Store, or 3rd party markets.


\section{Info Theft IncognitoWare}
Our first example of next-generation IncognitoWare is simple: embed PII stealing code into any app, but only execute it after the user has logged in. This act of logging in is sufficient to bypass automated monitoring tools like Google Bouncer. Only executing the code after the user has performed an action also creates a plausible scenario where the situation might have been intended. Ultimately, however, since nothing is presented to the user, such an action is a clear violation of the UAA, and is seen as malicious. Furthermore, we stay within the permission fingerprint of the original software, meaning not only is it invisible when installing, but blocking the permission outright, or feeding it fuzzed data, would ultimately result in legitimate actions being interfered with. This simple example is powerful enough to steal nearly all highly valuble PII from a device, but inconspicuous enough to be undetected, and legitimate enough to be unblocked.

AndroMEDA, however, can easily detect this example. \temp{Demonstrate this. with screenshots}. Seen in Figure \ref{somethingthatdoesntexistyet}, we demonstrate the malware without AndroMEDA, and in Figure \ref{somethingelse}, with AndroMEDA. After the user logs in, AndroMEDA immediately alerts the user that the PII has been read. The user then reviews it and decides that it's malware.

\section{Spyware IncognitoWare}
Our next example of sophisticated IncognitoWare is desinged to continuously spy on the user, while staying within the capabilities of a trusted app. We first find an app that has all the requirements for spyware: access to location, internet, wake lock, and starting at boot. We then introduce our malware, which is triggered 30 minutes after the first startup - long enough to evade Google Bouncer\citep{mansfield2012android}. After that, the device wakes up every 5 minutes, gathers a location fix, and sends that information to a remote location. As before, many examples exist of apps that use similar behavior for non malicious purposes, making policies to guard against it dfficult.

Once again, AndroMEDA can alert the user of this kind of behavior easily. Figure \ref{something} shows the user installing the app, starting it up, going to the home screen, and eventually noticing the suspicious behavior when the phone is idling. The user then inspects the logs for this app, finds this to be a continuous occurence, and decides that the app is malware.



